// This file has been autogenerated using elemental cli. 
// Use `npm run sync` to update from latest elemental specifications

import { PropertyDetails } from '../utils/const';
import { createFindErrorForIdentity, createValidateIdentity } from '../utils/validate';

/**
 * AccessPolicy allows to pass optional Rego access policy. If not set, The action is always Allow, If it is set, it will be run, and the final decision will be computed based on that policy. If the rego code does not start with package main, then the needed classic package definition and  acuvity imports will be added automatically. If the code starts with package main, then everything remains untouched.
 */
export type AccessPolicy = string | null;
/**
 * The name of the analyzers to run by the pipelines. If empty, it means all of them. Possible values are PIIs, Secrets, Topics, Confidentiality, Exploits.
 */
export type Analyzers = (string | null)[];
/**
 * How to anonymize the data. If deanonymize is true, then VariablSize is required.
 */
export type Anonymization = "FixedSize" | "VariableSize";
/**
 * In the case of a contentPolicy that asks for a confirmation, this is the hash you must send back to bypass the block. This is only useful when a content policy has been set.
 */
export type BypassHash = string | null;
/**
 * ContentPolicy allows to pass optional Rego content policy. If not set, The action is always Allow, and there cannot be any alerts raised etc If it is set, it will be run, and the final decision will be computed based on that policy. If the rego code does not start with package main, then the needed classic package definition and  acuvity imports will be added automatically. If the code starts with package main, then everything remains untouched.
 */
export type ContentPolicy = string | null;
/**
 * The binary data to request extraction for.
 */
export type Data = string;
/**
 * If true, this extraction is for internal use only. This can be used by agentic systems to mark an extraction as internal only as opposed to user facing.
 */
export type Internal = boolean | null;
/**
 * A means of distinguishing what was extracted, such as prompt, input file or code.
 */
export type Label = string | null;
/**
 * The extractions to request.
 */
export type Extractions = ExtractionRequest[];
/**
 * The keywords found during classification.
 */
export type Keywords = (string | null)[];
/**
 * Messages to process and provide detections for. Use data in extractions for processing binary data.
 */
export type Messages = (string | null)[];
/**
 * If true, the system will not log the contents that were scanned.
 */
export type MinimalLogging = boolean | null;
/**
 * The redactions that has been performed.
 */
export type Redactions = (string | null)[];
/**
 * The type of text.
 */
export type Type = "Input" | "Output";
/**
 * List of claims extracted from the user query.
 */
export type Claims = string[];
/**
 * The name of the external user.
 */
export type Name = string;

/**
 * This is a scan request.
 */
export interface ScanRequest {
  accessPolicy?: AccessPolicy;
  analyzers?: Analyzers;
  annotations?: Annotations;
  anonymization?: Anonymization;
  bypassHash?: BypassHash;
  contentPolicy?: ContentPolicy;
  extractions?: Extractions;
  keywords?: Keywords;
  messages?: Messages;
  minimalLogging?: MinimalLogging;
  redactions?: Redactions;
  type?: Type;
  user?: User;
}
/**
 * Annotations attached to the extraction.
 */
export interface Annotations {
  [k: string]: unknown;
}
/**
 * Represents the extraction that the user wants to extract.
 */
export interface ExtractionRequest {
  annotations?: Annotations1;
  data?: Data;
  internal?: Internal;
  label?: Label;
  [k: string]: unknown;
}
/**
 * Annotations attached to the extraction.
 */
export interface Annotations1 {
  [k: string]: unknown;
}
/**
 * The user information that the ScanRequest is passing on to the policy engine.
 */
export interface User {
  claims: Claims;
  name: Name;
  [k: string]: unknown;
}


// createValidateIdentity<ScanRequest> creates a validator for the the elemental identity ScanRequest
export const validateScanRequest = createValidateIdentity<ScanRequest>('scanrequest');

export const ScanRequestProperties: Record<keyof ScanRequest, PropertyDetails> = {
  "accessPolicy": {
    "description": "AccessPolicy allows to pass optional Rego access policy. If not set, The action is always Allow, If it is set, it will be run, and the final decision will be computed based on that policy. If the rego code does not start with package main, then the needed classic package definition and  acuvity imports will be added automatically. If the code starts with package main, then everything remains untouched.",
    "title": "Access Policy",
    "type": [
      "string",
      "null"
    ]
  },
  "analyzers": {
    "description": "The name of the analyzers to run by the pipelines. If empty, it means all of them. Possible values are PIIs, Secrets, Topics, Confidentiality, Exploits.",
    "title": "Analyzers",
    "type": "array"
  },
  "annotations": {
    "description": "Annotations attached to the extraction.",
    "title": "Annotations",
    "type": "object"
  },
  "anonymization": {
    "defaultValue": "FixedSize",
    "description": "How to anonymize the data. If deanonymize is true, then VariablSize is required.",
    "title": "Anonymization"
  },
  "bypassHash": {
    "description": "In the case of a contentPolicy that asks for a confirmation, this is the hash you must send back to bypass the block. This is only useful when a content policy has been set.",
    "title": "Bypass Hash",
    "type": [
      "string",
      "null"
    ]
  },
  "contentPolicy": {
    "description": "ContentPolicy allows to pass optional Rego content policy. If not set, The action is always Allow, and there cannot be any alerts raised etc If it is set, it will be run, and the final decision will be computed based on that policy. If the rego code does not start with package main, then the needed classic package definition and  acuvity imports will be added automatically. If the code starts with package main, then everything remains untouched.",
    "title": "Content Policy",
    "type": [
      "string",
      "null"
    ]
  },
  "extractions": {
    "description": "The extractions to request.",
    "title": "Extractions",
    "type": "array"
  },
  "keywords": {
    "description": "The keywords found during classification.",
    "title": "Keywords",
    "type": "array"
  },
  "messages": {
    "description": "Messages to process and provide detections for. Use data in extractions for processing binary data.",
    "title": "Messages",
    "type": "array"
  },
  "minimalLogging": {
    "description": "If true, the system will not log the contents that were scanned.",
    "title": "MinimalLogging",
    "type": [
      "boolean",
      "null"
    ]
  },
  "redactions": {
    "description": "The redactions that has been performed.",
    "title": "Redactions",
    "type": "array"
  },
  "type": {
    "description": "The type of text.",
    "title": "Type"
  },
  "user": {
    "description": "The user information that the ScanRequest is passing on to the policy engine.",
    "title": "User"
  },
}

// ScanRequestIdentity
export const ScanRequestIdentity = {
  isIdentity: true,
  description: `This is a scan request.`,
  title: `ScanRequest`,
  friendlyName: `ScanRequest`,
  friendlyNamePlural: `ScanRequests`,
  name: 'ScanRequest',
  restName: 'scanrequest',
  resourceName: 'scanrequests',
  package: 'colektor',
  archivable: false,
  findErrorForIdentity: createFindErrorForIdentity('scanrequest'),
  properties: ScanRequestProperties,
} as const;
