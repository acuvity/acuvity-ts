/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  Extractionrequest,
  Extractionrequest$inboundSchema,
  Extractionrequest$Outbound,
  Extractionrequest$outboundSchema,
} from "./extractionrequest.js";

/**
 * How to anonymize the data. If deanonymize is true, then VariablSize is required.
 */
export const ScanrequestAnonymization = {
  FixedSize: "FixedSize",
  VariableSize: "VariableSize",
} as const;
/**
 * How to anonymize the data. If deanonymize is true, then VariablSize is required.
 */
export type ScanrequestAnonymization = ClosedEnum<
  typeof ScanrequestAnonymization
>;

/**
 * The type of text.
 */
export const ScanrequestType = {
  Input: "Input",
  Output: "Output",
} as const;
/**
 * The type of text.
 */
export type ScanrequestType = ClosedEnum<typeof ScanrequestType>;

/**
 * This is a scan request.
 */
export type Scanrequest = {
  /**
   * AccessPolicy allows to pass optional Rego access policy. If not set,
   *
   * @remarks
   * The action is always Allow,
   * If it is set, it will be run, and the final decision will be computed based
   * on that policy.
   * If the rego code does not start with package main, then the needed
   * classic package definition and  acuvity imports will be added
   * automatically.
   * If the code starts with package main, then everything remains untouched.
   */
  accessPolicy?: string | undefined;
  /**
   * The name of the analyzers to run by the pipelines. If empty, it means all of
   *
   * @remarks
   * them. Possible values are PIIs, Secrets, Topics, Confidentiality, Exploits.
   */
  analyzers?: Array<string> | undefined;
  /**
   * Annotations attached to the extraction.
   */
  annotations?: { [k: string]: string } | undefined;
  /**
   * How to anonymize the data. If deanonymize is true, then VariablSize is required.
   */
  anonymization?: ScanrequestAnonymization | undefined;
  /**
   * In the case of a contentPolicy that asks for a confirmation, this is the
   *
   * @remarks
   * hash you must send back to bypass the block. This is only useful when a
   * content policy has been set or is evaluated remotely.
   */
  bypassHash?: string | undefined;
  /**
   * ContentPolicy allows to pass optional Rego content policy. If not set,
   *
   * @remarks
   * The action is always Allow, and there cannot be any alerts raised etc
   * If it is set, it will be run, and the final decision will be computed based
   * on that policy.
   * If the rego code does not start with package main, then the needed
   * classic package definition and  acuvity imports will be added
   * automatically.
   * If the code starts with package main, then everything remains untouched.
   */
  contentPolicy?: string | undefined;
  /**
   * The extractions to request.
   */
  extractions?: Array<Extractionrequest> | undefined;
  /**
   * The keywords found during classification.
   */
  keywords?: Array<string> | undefined;
  /**
   * Messages to process and provide detections for. Use data in extractions for
   *
   * @remarks
   * processing binary data.
   */
  messages?: Array<string> | undefined;
  /**
   * If true, the system will not log the contents that were scanned.
   */
  minimalLogging?: boolean | undefined;
  /**
   * The redactions to perform if they are detected.
   */
  redactions?: Array<string> | undefined;
  /**
   * The type of text.
   */
  type?: ScanrequestType | undefined;
};

/** @internal */
export const ScanrequestAnonymization$inboundSchema: z.ZodNativeEnum<
  typeof ScanrequestAnonymization
> = z.nativeEnum(ScanrequestAnonymization);

/** @internal */
export const ScanrequestAnonymization$outboundSchema: z.ZodNativeEnum<
  typeof ScanrequestAnonymization
> = ScanrequestAnonymization$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ScanrequestAnonymization$ {
  /** @deprecated use `ScanrequestAnonymization$inboundSchema` instead. */
  export const inboundSchema = ScanrequestAnonymization$inboundSchema;
  /** @deprecated use `ScanrequestAnonymization$outboundSchema` instead. */
  export const outboundSchema = ScanrequestAnonymization$outboundSchema;
}

/** @internal */
export const ScanrequestType$inboundSchema: z.ZodNativeEnum<
  typeof ScanrequestType
> = z.nativeEnum(ScanrequestType);

/** @internal */
export const ScanrequestType$outboundSchema: z.ZodNativeEnum<
  typeof ScanrequestType
> = ScanrequestType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ScanrequestType$ {
  /** @deprecated use `ScanrequestType$inboundSchema` instead. */
  export const inboundSchema = ScanrequestType$inboundSchema;
  /** @deprecated use `ScanrequestType$outboundSchema` instead. */
  export const outboundSchema = ScanrequestType$outboundSchema;
}

/** @internal */
export const Scanrequest$inboundSchema: z.ZodType<
  Scanrequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  accessPolicy: z.string().optional(),
  analyzers: z.array(z.string()).optional(),
  annotations: z.record(z.string()).optional(),
  anonymization: ScanrequestAnonymization$inboundSchema.default("FixedSize"),
  bypassHash: z.string().optional(),
  contentPolicy: z.string().optional(),
  extractions: z.array(Extractionrequest$inboundSchema).optional(),
  keywords: z.array(z.string()).optional(),
  messages: z.array(z.string()).optional(),
  minimalLogging: z.boolean().optional(),
  redactions: z.array(z.string()).optional(),
  type: ScanrequestType$inboundSchema.optional(),
});

/** @internal */
export type Scanrequest$Outbound = {
  accessPolicy?: string | undefined;
  analyzers?: Array<string> | undefined;
  annotations?: { [k: string]: string } | undefined;
  anonymization: string;
  bypassHash?: string | undefined;
  contentPolicy?: string | undefined;
  extractions?: Array<Extractionrequest$Outbound> | undefined;
  keywords?: Array<string> | undefined;
  messages?: Array<string> | undefined;
  minimalLogging?: boolean | undefined;
  redactions?: Array<string> | undefined;
  type?: string | undefined;
};

/** @internal */
export const Scanrequest$outboundSchema: z.ZodType<
  Scanrequest$Outbound,
  z.ZodTypeDef,
  Scanrequest
> = z.object({
  accessPolicy: z.string().optional(),
  analyzers: z.array(z.string()).optional(),
  annotations: z.record(z.string()).optional(),
  anonymization: ScanrequestAnonymization$outboundSchema.default("FixedSize"),
  bypassHash: z.string().optional(),
  contentPolicy: z.string().optional(),
  extractions: z.array(Extractionrequest$outboundSchema).optional(),
  keywords: z.array(z.string()).optional(),
  messages: z.array(z.string()).optional(),
  minimalLogging: z.boolean().optional(),
  redactions: z.array(z.string()).optional(),
  type: ScanrequestType$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Scanrequest$ {
  /** @deprecated use `Scanrequest$inboundSchema` instead. */
  export const inboundSchema = Scanrequest$inboundSchema;
  /** @deprecated use `Scanrequest$outboundSchema` instead. */
  export const outboundSchema = Scanrequest$outboundSchema;
  /** @deprecated use `Scanrequest$Outbound` instead. */
  export type Outbound = Scanrequest$Outbound;
}

export function scanrequestToJSON(scanrequest: Scanrequest): string {
  return JSON.stringify(Scanrequest$outboundSchema.parse(scanrequest));
}

export function scanrequestFromJSON(
  jsonString: string,
): SafeParseResult<Scanrequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Scanrequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Scanrequest' from JSON`,
  );
}
