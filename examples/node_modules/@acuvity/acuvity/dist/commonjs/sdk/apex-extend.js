"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const apex_js_1 = require("./apex.js");
const components = __importStar(require("../models/components/index.js"));
// Add the method implementation to the class prototype
apex_js_1.Apex.prototype.scan = async function ({ messages, files, requestType, annotations, analyzers, bypassHash, anonymization, redactions, keywords, accessPolicy, contentPolicy, }) {
    const request = {};
    if (messages) {
        if (typeof messages === "string") {
            request.messages = [messages];
        }
        else if (Array.isArray(messages) && messages.every((m) => typeof m === "string")) {
            request.messages = messages;
        }
    }
    if ((!request.messages || request.messages.length === 0) && !files) {
        throw new Error("no messages and no files provided");
    }
    if (files) {
        let processFiles = [];
        if (typeof files === "string") {
            processFiles = [files];
        }
        else if (Array.isArray(files) && files.every((f) => typeof f === "string")) {
            processFiles = files;
        }
        const extractions = [];
        for (const processFile of processFiles) {
            const fileContent = await readFileAndBase64Encode(processFile);
            extractions.push({
                data: fileContent,
            });
        }
        request.extractions = extractions;
    }
    request.type = components.Type.Input;
    if (requestType) {
        if (typeof requestType === "string") {
            if (requestType === "Input" || requestType === "Output") {
                request.type = requestType;
            }
        }
        else if (typeof requestType === "object") {
            request.type = requestType;
        }
    }
    if (annotations) {
        if (typeof annotations === "object") {
            request.annotations = annotations;
        }
    }
    if (analyzers) {
        if (Array.isArray(analyzers)) {
            const analyzers_list = (await this.listAnalyzerGroups()).concat(await this.listAnalyzerNames());
            for (let analyzer of analyzers) {
                if (typeof analyzer !== "string") {
                    throw new Error("analyzers must be strings");
                }
                if (analyzer.startsWith("+") || analyzer.startsWith("-")) {
                    analyzer = analyzer.slice(1);
                }
                if (!analyzers_list.includes(analyzer)) {
                    throw new Error(`analyzer '${analyzer}' is not in list of analyzer groups or analyzers: ${analyzers_list}`);
                }
            }
            request.analyzers = analyzers;
        }
    }
    if (bypassHash) {
        if (typeof bypassHash === "string") {
            request.bypassHash = bypassHash;
        }
    }
    request.anonymization = components.Anonymization.FixedSize;
    if (anonymization) {
        if (typeof anonymization === "string") {
            if (anonymization === "FixedSize" || anonymization === "VariableSize") {
                request.anonymization = anonymization;
            }
        }
        else if (typeof anonymization === "object") {
            request.anonymization = anonymization;
        }
    }
    if (redactions) {
        if (Array.isArray(redactions) && redactions.every((r) => typeof r === "string")) {
            request.redactions = redactions;
        }
    }
    if (keywords) {
        if (Array.isArray(keywords) && keywords.every((k) => typeof k === "string")) {
            request.keywords = keywords;
        }
    }
    if (accessPolicy) {
        if (typeof accessPolicy === "string") {
            request.accessPolicy = accessPolicy;
        }
    }
    if (contentPolicy) {
        if (typeof contentPolicy === "string") {
            request.contentPolicy = contentPolicy;
        }
    }
    return this.scanRequest(request);
};
apex_js_1.Apex.prototype.police = async function ({ messages, files, requestType, annotations, bypassHash, anonymization, provider, user, }) {
    const request = {};
    if (messages) {
        if (typeof messages === "string") {
            request.messages = [messages];
        }
        else if (Array.isArray(messages) && messages.every((m) => typeof m === "string")) {
            request.messages = messages;
        }
    }
    if ((!request.messages || request.messages.length === 0) && !files) {
        throw new Error("no messages and no files provided");
    }
    if (files) {
        let processFiles = [];
        if (typeof files === "string") {
            processFiles = [files];
        }
        else if (Array.isArray(files) && files.every((f) => typeof f === "string")) {
            processFiles = files;
        }
        const extractions = [];
        for (const processFile of processFiles) {
            const fileContent = await readFileAndBase64Encode(processFile);
            extractions.push({
                data: fileContent,
            });
        }
        request.extractions = extractions;
    }
    request.type = components.Type.Input;
    if (requestType) {
        if (typeof requestType === "string") {
            if (requestType === "Input" || requestType === "Output") {
                request.type = requestType;
            }
        }
        else if (typeof requestType === "object") {
            request.type = requestType;
        }
    }
    if (annotations) {
        if (typeof annotations === "object") {
            request.annotations = annotations;
        }
    }
    if (bypassHash) {
        if (typeof bypassHash === "string") {
            request.bypassHash = bypassHash;
        }
    }
    request.anonymization = components.Anonymization.FixedSize;
    if (anonymization) {
        if (typeof anonymization === "string") {
            if (anonymization === "FixedSize" || anonymization === "VariableSize") {
                request.anonymization = anonymization;
            }
        }
        else if (typeof anonymization === "object") {
            request.anonymization = anonymization;
        }
    }
    if (provider) {
        if (typeof provider === "string") {
            request.provider = provider;
        }
    }
    if (user) {
        if (typeof user === "object") {
            request.user = user;
        }
    }
    return this.policeRequest(request);
};
async function readFileAndBase64Encode(filePath) {
    const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
    if (isBrowser) {
        // Running in a browser
        throw new Error("File reading is not supported in the browser.");
    }
    // Dynamically import `fs/promises` for server runtimes
    if (typeof Deno !== "undefined") {
        const { readFile } = await import("node:fs/promises");
        // read file and base64 encode
        const fileContent = await readFile(filePath);
        return fileContent.toString("base64");
    }
    else {
        const { readFile } = await import("fs/promises");
        // read file and base64 encode
        const fileContent = await readFile(filePath);
        return fileContent.toString("base64");
    }
}
apex_js_1.Apex.prototype.listAnalyzers = async function () {
    return (this._available_analyzers ?? (this._available_analyzers = await this.listAnalyzers()));
};
apex_js_1.Apex.prototype.listAnalyzerNames = async function (group) {
    const analyzers = (this._available_analyzers ?? (this._available_analyzers = await this.listAnalyzers()));
    return analyzers
        .filter((a) => !group || a.group === group)
        .map((a) => a.id ?? "")
        .filter((a) => a !== "")
        .sort();
};
apex_js_1.Apex.prototype.listAnalyzerGroups = async function () {
    const analyzers = (this._available_analyzers ?? (this._available_analyzers = await this.listAnalyzers()));
    return analyzers
        .map((a) => a.group ?? "")
        .filter((a) => a !== "")
        .filter((v, i, a) => a.indexOf(v) === i)
        .sort();
};
//# sourceMappingURL=apex-extend.js.map